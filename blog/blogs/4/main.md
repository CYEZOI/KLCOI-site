# 2024“钉耙编程”中国大学生算法设计超级联赛一 J - 众数## 简要题意有一个长度为 $n$，取值在 $[1,n]$ 中随机的序列 $a$。有 $q$ 次询问，给出 $[l,r]$，求出所有 $[l,r]$ 的子区间最大值的众数。若出现次数一样则选择值更大的。$1 \le n , q \le 2\times10^5$。## 题解先考虑暴力。考虑枚举区间的每一个数，考虑其贡献。   若枚举到第 $i$ 个数，则若序列 $[l,i-1]$ 和 $[i+1,r]$ 中大小没有超过 $a_i$ 的数，则产生贡献。  但是有多个相同的数，这时候直接算要么大要么小。  考虑对于一个位置 $i$，记录左边第一个比 $a_i$ 大的位置 $pre$，和右边第一个大于等于 $a_i$ 的位置 $nxt$，其贡献即为 $(i-pre)(nxt-i)$，此时能做道不重不漏。这里用单调栈求出 $pre$ 与 $nxt$。考虑大数据，发现数列随机，考虑省略步骤。  发现一个数越大，两边可期望延伸就越长。  所以大的数有优势，期望贡献就越大。但是一个大数若在边角上，这是贡献就少了，所以为了保证正确性，选取前 $k=50$ 大的数即可。    考虑如何累加贡献，因为数据随机，一个数出现期望次数为 $1$，直接暴力存所有数的位置，然后算贡献即可。用线段树维护前 $k$ 大的，时间复杂度 $O(nk\log n)$。```cppconst int N = 2e5 + 5;const int K = 50;int n, q, a[N];int pre[N], nxt[N], stk[N], tp;vector<int> e[N];struct Node {	int a[K + 2];	friend Node operator + (Node A, Node B) {		Node res;		int c1 = 1, c2 = 1;		FOR(i, 1, K) {			if(A.a[c1] >= B.a[c2]) res.a[i] = A.a[c1++];			else res.a[i] = B.a[c2++];			if(res.a[i] && res.a[i] == res.a[i - 1]) i--;		}		return res;	}};struct SgT {	int le[N << 2], ri[N << 2];	Node F[N << 2];	void pushup(int u) {		F[u] = F[u << 1] + F[u << 1 | 1];	}	void build(int u, int l, int r) {		le[u] = l, ri[u] = r;		if(l == r) {			F[u].a[1] = a[l];			return;		}		int mid = l + r >> 1;		build(u << 1, l, mid);		build(u << 1 | 1, mid + 1, r);		pushup(u);	}	Node query(int u, int l, int r) {		if(l <= le[u] && ri[u] <= r) {			return F[u];		}		int mid = le[u] + ri[u] >> 1;		if(r <= mid) return query(u << 1, l, r);		if(mid < l) return query(u << 1 | 1, l, r);		return query(u << 1, l, r) + query(u << 1 | 1, l, r);	}} t;void solve() {	cin >> n >> q;	FOR(i, 1, n) cin >> a[i];	FOR(i, 1, n) e[i].clear();	FOR(i, 1, n) e[a[i]].push_back(i);	t.build(1, 1, n);	tp = 0; stk[tp] = 0;	FOR(i, 1, n) {		while(tp && a[stk[tp]] <= a[i]) tp--;		pre[i] = stk[tp];		stk[++tp] = i;	}	tp = 0; stk[tp] = n + 1;	ROF(i, n, 1) {		while(tp && a[stk[tp]] < a[i]) tp--;		nxt[i] = stk[tp];		stk[++tp] = i;	}	ll ans = 0;	FOR(i, 1, q) {		int l, r;		cin >> l >> r;		Node h = t.query(1, l, r);		int res = 0;		ll mx = 0;		FOR(j, 1, K) {			int u = h.a[j];			if(!u) break;			ll val = 0;			for(int p : e[u]) if(l <= p && p <= r) {				int L = max(l, pre[p] + 1);				int R = min(r, nxt[p] - 1);				val += 1ll * (p - L + 1) * (R - p + 1);			}			if(val > mx) {				mx = val;				res = u;			}			else if(val == mx && u > res) {				res = u;			}		}		ans ^= (1ll * i * res);	}	cout << ans << endl;}```